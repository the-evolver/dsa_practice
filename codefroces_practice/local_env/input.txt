3
12 15 18









































































































































































// int t;
// cin >> t;
// vector<int> arr(t, -1);
// map<ll, ll> pyramidMap = helperPyramid();

// for (int i = 0 ; i < arr.size(); i++) {

//     cin >> arr[i];
// }

// for (int i = 0 ; i < arr.size(); i++) {
//     //cout << i << arr[i] << endl;
//     solve(arr[i], pyramidMap);


// }
// long solve(vector<int> arr , int k){

//     int src = 0;
//     unordered_map<int,int> mp;
//     int ans = 0;
//     int curr_sum = 0;

//     for(int j = 0 ; j < arr.size() ;j++){

//          mp[arr[j]]++;
//          curr_sum = curr_sum + arr[j];
//          while(j - src >= k || mp[arr[j]] > 1){

//              curr_sum = curr_sum - arr[src];
//              mp[arr[src]] = mp[arr[src]] - 1;

//              src++;



//          }
//          cout<<endl;
//          ans = max(ans,curr_sum);

//     }
//     return ans == 0 ? -1 : ans ;

// }

// vector<int> fl(vector<int>& locations , vector<int>& movedFrom , vector<int>& movedTo) {

//     int m = movedTo.size(), n = locations.size() ;


//     unordered_map<int, int> mp;
//     for (int i = 0; i < m; i++)
//     {

//         mp[movedFrom[i]] = movedTo[i];
//     }

//     for (int i = 0; i < n; i++)
//     {

//         if (mp.find(locations[i]) != mp.end() and mp[locations[i]] != -1)
//         {

//             int tar = mp[locations[i]];

//             mp[locations[i]] = -1;

//             while (mp.find(tar) != mp.end() and mp[tar] != -1)
//             {
//                 tar = mp[tar];

//                 mp[tar] = -1;
//             }

//             locations[i] = tar;
//         }
//     }

//     sort(locations.begin(), locations.end());


//     return locations;
// }


// long findMaximumSum(vector<int> stockPrice, int k) {
//     long src = 0;
//     unordered_map< long, long> mp;
//     long ans = 0;
//     long curr_sum = 0;
//     int curr_len = 0;

//     for (long j = 0; j < stockPrice.size(); ++j) {

//         mp[stockPrice[j]]++;
//         curr_len++;
//         curr_sum = curr_sum + stockPrice[j];
//         while (j - src >= k || mp[stockPrice[j]] > 1) {
//             curr_sum = curr_sum - stockPrice[src];
//             mp[stockPrice[src]] = mp[stockPrice[src]] - 1;
//             src++;
//             curr_len--;
//         }
//         cout << endl;
//         if (curr_len >= k)
//             ans = max(ans, curr_sum);
//     }
//     return ans == 0 ? -1 : ans;
// }

// int n1;
// cin >> n1;
// vector<int> arr1(n1, 0);
// for (int i = 0 ; i < n1 ; i++) {
//     cin >> arr1[i];
// }
// int n2;
// cin >> n2;
// vector<int> arr2(n2, 0);
// for (int i = 0 ; i < n2 ; i++) {
//     cin >> arr2[i];
// }
// cout << "Before reverse" << endl;
// print(n1, arr1);
// print(n2, arr2);
// cout << "After reverse" << endl;
// reverse(n1, arr1);
// reverse(n2, arr2);

// print(n1, arr1);
// print(n2, arr2);
// cout << " after Merge" << endl;
// merge(n1, arr1, n2, arr2);





// vector<int> v{1, 2, 4, 4};
// cout << findMaximumSum(v, 4);


// int n, row, col;
// cin >> n >> row >> col;
// vector<vector<int>> chess;
// printKnightsTour(chess, n, row, col, -1);


// int vtces;
// cin >> vtces;
// vector<vector<Edge>> graph(vtces, vector<Edge>());


// int edges;
// cin >> edges;

// vector<pair<int, int>>* adj = new vector<pair<int, int>>[vtces];

// for (int i = 0; i < edges; i++ ) {
//     int u, v, w;
//     cin >> u >> v >> w;


//     adj[u].push_back({v, w});
//     adj[v].push_back({u, w});

// }

// int src ;
// cin >> src;

// //shortest_weight(adj, src, vtces) ;
// shortest_weight_using_bfs(adj, src, vtces);


// int vtces;
// cin >> vtces;
// vector<vector<Edge>> graph(vtces, vector<Edge>());
// vector<int>* adj = new vector<int>[vtces];

// int edges;
// cin >> edges;

// for (int i = 0; i < edges; i++ ) {
//     int u, v, w;
//     cin >> u >> v >> w;
//     graph[u].push_back(Edge(u, v));
//     graph[v].push_back(Edge(v, u));
//     adj[u].push_back(v);
//     adj[v].push_back(u);
// }

// int src;
// cin >> src;

// bfs_helper(adj, src, vtces);






Â 